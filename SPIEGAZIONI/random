## 6. random

Questa sfida é stata piuttosto semplice, dando un'occhiata veloce al codice:

#include <stdio.h>

int main(){
	unsigned int random;
	random = rand();	// random value!

	unsigned int key=0;
	scanf("%d", &key);

	if( (key ^ random) == 0xdeadbeef ){
		printf("Good!\n");
		system("/bin/cat flag");
		return 0;
	}

	printf("Wrong, maybe you should try 2^32 cases.\n");
	return 0;
}

Capiamo che il programma sta creando numero casuale tramite la funzione rand(), poi ci chiede come input un numero ed esegue l'operazione  XOR (Exclusive OR), un'operazione bitwise che ritorna 1 se soltanto uno dei due bit é uno e ritorna 0 se entrambi i bit sono 0 o entrambi i bit sono 1, tra il numero che forniamo al programma e quello generato casualmente, se il risultato di questa operazione é il numero 0xdeadbeef allora il programma ci fornirá la flag.
Ma il numero che viene creato tramite la funzione rand() é veramente casuale?
L'algoritmo che sceglie i numeri casuali che vengono restituiti dalla funzione rand() si basa su un seed, impostabile tramite la funzione srand(int), su quel valore si basa la sequenza di numeri che verrá fornita dalla funzione rand(), se il seed non é peró impostato manualmente (come succede in questo programma) verrá utilizzato il seed di default 1, che fornisce sempre la stessa sequenza.
Possiamo verificare ció anche con gdb, basta trovare l'indirizzo della variabile random e vedere se eseguendo il programma due volte otteniamo lo stesso valore:

(gdb) disas main
Dump of assembler code for function main:
   0x00000000004005f4 <+0>:	push   %rbp
   0x00000000004005f5 <+1>:	mov    %rsp,%rbp
   0x00000000004005f8 <+4>:	sub    $0x10,%rsp
   0x00000000004005fc <+8>:	mov    $0x0,%eax
   0x0000000000400601 <+13>:	callq  0x400500 <rand@plt>
   0x0000000000400606 <+18>:	mov    %eax,-0x4(%rbp)
   0x0000000000400609 <+21>:	movl   $0x0,-0x8(%rbp)
   0x0000000000400610 <+28>:	mov    $0x400760,%eax
   0x0000000000400615 <+33>:	lea    -0x8(%rbp),%rdx
   0x0000000000400619 <+37>:	mov    %rdx,%rsi
   0x000000000040061c <+40>:	mov    %rax,%rdi
   0x000000000040061f <+43>:	mov    $0x0,%eax
   0x0000000000400624 <+48>:	callq  0x4004f0 <__isoc99_scanf@plt>
   0x0000000000400629 <+53>:	mov    -0x8(%rbp),%eax
   0x000000000040062c <+56>:	xor    -0x4(%rbp),%eax
   0x000000000040062f <+59>:	cmp    $0xdeadbeef,%eax
   0x0000000000400634 <+64>:	jne    0x400656 <main+98>
   0x0000000000400636 <+66>:	mov    $0x400763,%edi
   0x000000000040063b <+71>:	callq  0x4004c0 <puts@plt>
   0x0000000000400640 <+76>:	mov    $0x400769,%edi
   0x0000000000400645 <+81>:	mov    $0x0,%eax
   0x000000000040064a <+86>:	callq  0x4004d0 <system@plt>
   0x000000000040064f <+91>:	mov    $0x0,%eax
   0x0000000000400654 <+96>:	jmp    0x400665 <main+113>
   0x0000000000400656 <+98>:	mov    $0x400778,%edi
   0x000000000040065b <+103>:	callq  0x4004c0 <puts@plt>
   0x0000000000400660 <+108>:	mov    $0x0,%eax
   0x0000000000400665 <+113>:	leaveq 
   0x0000000000400666 <+114>:	retq   
End of assembler dump.

Disassemblando il main notiamo che quando facciamo l'operazione di xor lo xor viene fatto tra $rbp-0x4 e il contenuto di eax, che possiamo vedere dalla riga precedente essere $rbp-0x8, perció il valore random si trova sicuramente in una delle due posizioni.
Facendo partire il programma impostando un breakpoint dopo la chiamata alla funzione rand possiamo analizzare entrambi gli indirizzi:

(gdb) break *0x0000000000400610
Breakpoint 1 at 0x400610
(gdb) r
Starting program: /home/random/random 

Breakpoint 1, 0x0000000000400610 in main ()
(gdb) x/d $rbp-0x4
0x7ffd0326dd4c:	1804289383
(gdb) x/d $rbp-0x8
0x7ffd0326dd48:	0
(gdb) 

Capiamo quindi che il valore random sta a $rbp-0x4.
Ora facciamo ripartire il programma.
Breakpoint 1, 0x0000000000400610 in main ()
(gdb) x $rbp-4
0x7ffd5f2d029c:	1804289383

Notiamo che i due valori sono identici, perció basterá trovare quel valore tale che 1804289383 ^ X = deadbeef
Per fare ció a mano basta scrivere i due numeri in binario e fare un po di calcoli.
1804289383 = 01101011100010110100010101100111 (Scrivere tutti i 32 bit)
X =          10110101001001101111101110001000
deadbeef =   11011110101011011011111011101111

Per calcolare X basta osservare, se in quella posizione deadbeef ha 1, se il numero conosciuto ha 1, allora X avrá 0, altrimenti avrá 1, sedeadbeef ha 0, se il numero conosciuto ha 1, allora X avrá anch'esso 1, se il numero conosciuto ha 0, anche X avrá 0.

Convertendo in decimale X = 3039230856 e ora basterá inserirlo nel programma.

random@pwnable:~$ echo "3039230856" | ./random
Good!
Mommy, I thought libc random is unpredictable...


