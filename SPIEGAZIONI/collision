##2. collision 
Collision tratta delle collisioni che possono avvenire nelle funzioni di hashing non sicure, le funzioni di hashing sono funzioni che associano ad un valore uno ed un solo valore, sono usate nella crittografia spesso per controllare le validita delle password, questo proprio perchè un hash è (o dovrebbe essere) collegato ad un solo valore, tuttavia in funzioni hash insicure possono avvenire delle cosiddette collisioni, che si verificano quando ad uno stesso valore hash sono associati + valori diversi tra di loro, quando è molto facile trovare delle collisioni in una hash function quest'ultima è ritenuta insicura e deprecata all'uso.
Collegandosi alla shell remota come per la challenge fd notiamo la flag che non possiamo leggere e il programma col:
#include <stdio.h>
#include <string.h>
unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i<5; i++){
		res += ip[i];
	}
	return res;
}

int main(int argc, char* argv[]){
	if(argc<2){
		printf("usage : %s [passcode]\n", argv[0]);
		return 0;
	}
	if(strlen(argv[1]) != 20){
		printf("passcode length should be 20 bytes\n");
		return 0;
	}

	if(hashcode == check_password( argv[1] )){
		system("/bin/cat flag");
		return 0;
	}
	else
		printf("wrong passcode.\n");
	return 0;
}

Analizzando il programma vediamo che ci viene subito dato il valore di hash contenuto nella variabile hashcode: 
	# unsigned long hashcode = 0x21DD09EC;
questo hash utilizza soltanto 4 byte (32 bit) e per questo sara molto facile da aggirare e si potranno trovare parecchie collisioni, in particolare il programma ci chiede una password di 20 caratteri, la funzione check_password diventa poi protagonista del programma.
Sappiamo che in C il tipo stringa non esiste, per fare una stringa noi dobbiamo creare un "array" (anche dire array non e del tutto corretto, ma prendiamolo per buono intendendo array come la zona di memoria che contiene gli elementi), assegnargli la quantita di memoria che vogliamo e inserire nelle giuste posizioni i caratteri, otterremo cosi un puntatore il cui valoree quello del primo elemento, e aggiungendo e sottraendo byte potremo scorrere i suoi elementi.
Ora chi ha studiato C e conosce bene il linguaggio sa cosa intende il programma con la linea:
	# int* ip = (int*) p;
In pratica il programma crea un array di interi facendo typecasting sulla nostra stringa, o array di caratteri per intenderci, e otteniamo quindi un array di interi.
In C questo e possibile poiche ad essere onesti oltre al fatto che non esistono array o stringhe, non esisterebbero neanche i caratteri, o meglio i caratteri stessi sono regolati da valori numerici tramite il formato ASCII, che comprende 256 caratteri (8 bit di caratteri), assegnando ad ognuno di essi un valore da 0 a 255, ad esempio la A maiuscola ha valore 65, se io quindi vado a scrivere le seguenti linee:
	# int a = 65;
	# printf("%c", (char)a);
L'output che otterro sara proprio A e non 65.
Tornando al nostro problema, nel linguaggio C il tipo char ha grandezza 1 byte (come detto prima, i caratteri ASCII sono 256, ossia 2^8), mentre il tipo int ha grandezza 4 byte, o 32 bit, questo implica che quando scorriamo il nostro array di caratteri, noi saltiamo di byte in byte, ma quando andiamo a convertire l'array di char in un int array dovremmo ora scorrere di 4 byte in 4 byte, se nell' array di caratteri prima avevamo 20 elementi, ora in quello di interi ne avremo solo 5, i cui valori sono determinati dai 4 byte formati dai precedenti byte dei caratteri.
Per risolvere il problema dobbiamo quindi trovare una stringa di 20 caratteri che convertita ad un array di interi dia come somma dei suoi valori il nostro valore hashcode.
Prendiamo dunque il valore di hashcode e convertiamolo in decimale, 0x21DD09EC = 568134124, ora sapendo che noi avremo a disposizione 5 interi da sommare per arrivare a questo numero, procederemo dividendo tale numero per 5, tenendo in mente che esso termina per 4 e dunque avremo resto 4:
	# 568134124 = 113626824 * 5 + 4 oppure 568134124 = 113626824 * 4 + 113626828
4 dei numeri necessari saranno quindi uguali, mentre il quinto sara piu grande soltanto di 4.
Ricordando che i caratteri possono essere scritti anche tramite due bit esadecimali, in questo modo:
	# \xXX, per esempio 'A' = '\x41'
Ci conviene convertire i numeri in esadecimale, avremo:
	# 113626824 = 6C5CEC8
	# 113626828 = 6C5CECC
Ci bastera quindi eseguire il programma e dare come input la stringa "\xc8\xce\xc5\x06" ripetuta 4 volte + "\xcc\xce\xc5\x06", consiglio di utilizzare o python o pearl (EDIT: a quanto pare pearl non e installato nella remote shell, percio basta usare il comando python e andra bene lo stesso) per stampare la stringa direttamente nell'esecuzione, in questo modo:
	# ./col $(python -c 'print("\xc8\xce\xc5\x06"*4 + "\xcc\xce\xc5\x06")')
	# ./col $(pearl -e 'print "\xc8\xce\xc5\x06"x4 . "\xcc\xce\xc5\x06"')
Avremo cosi ottenuto il contenuto della flag!



